{
    "raw_response": "```json\n{\n  \"multipleChoice\": [\n    {\n      \"question\": \"What is the key difference between array declarations in C and Java?\",\n      \"options\": [\n        \"A. C arrays require explicit size declarations, while Java arrays do not.\",\n        \"B. Java arrays perform bounds checking, while C arrays do not.\",\n        \"C. C arrays are heterogeneous, while Java arrays are homogeneous.\",\n        \"D. Java arrays are always dynamically sized, while C arrays are statically sized.\"\n      ],\n      \"correctAnswer\": \"B. Java arrays perform bounds checking, while C arrays do not.\",\n      \"explanation\": \"C lacks built-in bounds checking for arrays, leading to potential memory overwrites if indices are out of range. Java includes this safety feature.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Remember\"\n    },\n    {\n      \"question\": \"In C, what does `sizeof(array)` return, given `int array[10];`?\",\n      \"options\": [\n        \"A. The number of elements in the array (10)\",\n        \"B. The size of a single array element (4 bytes, usually)\",\n        \"C. The total size of the array in bytes (40 bytes, usually)\",\n        \"D. A pointer to the first element of the array\"\n      ],\n      \"correctAnswer\": \"C. The total size of the array in bytes (40 bytes, usually)\",\n      \"explanation\": \"`sizeof` operator returns the total memory occupied by the array, which is the element size multiplied by the number of elements.\",\n      \"courseOutcome\": \"CO4\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"What is the memory organization of a multi-dimensional array in C?\",\n      \"options\": [\n        \"A. Column-major order\",\n        \"B. Row-major order\",\n        \"C. Random order, determined at runtime\",\n        \"D. Depends on the compiler and operating system\"\n      ],\n      \"correctAnswer\": \"B. Row-major order\",\n      \"explanation\": \"C stores multi-dimensional arrays in row-major order, meaning elements of a row are stored contiguously in memory.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"What is the purpose of the `NULL` pointer in C?\",\n      \"options\": [\n        \"A. To point to the last element of an array\",\n        \"B. To point to a memory location containing zero\",\n        \"C. To indicate that a pointer does not currently point to any valid memory location\",\n        \"D. To represent an array of size zero\"\n      ],\n      \"correctAnswer\": \"C. To indicate that a pointer does not currently point to any valid memory location\",\n      \"explanation\": \"The `NULL` pointer is a special constant that signifies that a pointer does not point to a valid memory address.  Attempting to dereference it will usually lead to a crash.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Remember\"\n    },\n    {\n      \"question\": \"When an array is passed to a function in C, what is actually passed?\",\n      \"options\": [\n        \"A. A copy of the entire array\",\n        \"B. A pointer to the first element of the array\",\n        \"C. The number of elements in the array\",\n        \"D. The array's size in bytes\"\n      ],\n      \"correctAnswer\": \"B. A pointer to the first element of the array\",\n      \"explanation\": \"Arrays decay into pointers when passed to functions.  The function receives a pointer to the beginning of the array, not a copy of the data.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    }\n  ],\n  \"shortAnswer\": [\n    {\n      \"question\": \"Explain the concept of pointer arithmetic in C.\",\n      \"answer\": \"Pointer arithmetic allows adding or subtracting integers from pointers.  The amount added/subtracted is scaled by the size of the data type the pointer points to. For example, adding 1 to an `int*` increases the pointer's address by `sizeof(int)`. \",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"What is the purpose of type casting with void pointers?\",\n      \"answer\": \"Void pointers (`void*`) can point to any data type but lack type information. Type casting is necessary before dereferencing a `void*` to tell the compiler the intended data type, enabling pointer arithmetic and access to the data.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"Describe the representation of a string in C.\",\n      \"answer\": \"A C string is a null-terminated array of characters.  It consists of a sequence of characters followed by a special null character ('\\\\0') to mark the end of the string.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"What is the significance of `char **argv` in the `main` function?\",\n      \"answer\": \"In `main(int argc, char **argv)`, `argv` is a double pointer (pointer to a pointer) to an array of strings.  Each string represents a command-line argument passed to the program.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    },\n    {\n      \"question\": \"Why is it generally considered bad practice to directly mix array and pointer arithmetic?\",\n      \"answer\": \"While arrays and pointers are closely related in C, directly mixing pointer arithmetic on array names can lead to subtle bugs, especially concerning array bounds and pointer modification which are not checked by the compiler.  It's more robust to maintain distinct usage and explicitly handle array boundaries.\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Understand\"\n    }\n  ],\n  \"longAnswer\": [\n    {\n      \"question\": \"Explain the similarities and differences between arrays and pointers in C, providing examples to illustrate their relationship.\",\n      \"answer\": \"Arrays and pointers are intrinsically linked in C, but have crucial differences.  An array name, when used in expressions (except `sizeof` and `&`), decays into a pointer to its first element.  For instance, `int arr[5]; int *ptr = arr;` assigns the address of `arr[0]` to `ptr`.  Both can be used to access elements using the `[]` operator or pointer arithmetic.  However, `sizeof(arr)` returns the size of the entire array, while `sizeof(ptr)` returns the size of the pointer itself. Also,  arrays are fixed-size at compile time, while pointers can be modified to point to different memory locations.  Using pointer arithmetic on array names is often stylistically discouraged as it can obscure code clarity and lead to errors if not carefully managed.\",\n      \"markingScheme\": [\n        \"Correctly explaining the decay of an array name to a pointer (2 marks)\",\n        \"Illustrating with example code demonstrating array and pointer access (2 marks)\",\n        \"Clearly explaining the difference in behavior of `sizeof` for arrays and pointers (1 mark)\",\n        \"Pointing out the difference between fixed size arrays and dynamic pointer assignment (1 mark)\",\n        \"Mentioning the stylistic reasons for avoiding direct array and pointer arithmetic (1 mark)\"\n      ],\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Analyze\"\n    },\n    {\n      \"question\": \"Discuss the implications of the lack of bounds checking in C arrays, and explain strategies to mitigate the risks associated with this.\",\n      \"answer\": \"The absence of bounds checking in C arrays is a double-edged sword.  It provides performance benefits but introduces the risk of buffer overflows â€“ writing data beyond the allocated array bounds, potentially corrupting adjacent memory areas or causing program crashes. Strategies for mitigation include: (1) careful programming, thoroughly checking array indices before accessing elements; (2) using safer alternatives like standard library functions (e.g., `strncpy`, `fgets`) that provide bounds checking; (3) employing static analysis tools during development to detect potential buffer overflows; and (4) using more modern languages that inherently include bounds checking.  Defensive programming techniques such as pre-checking array bounds at runtime help reduce the probability of this type of error.\",\n      \"markingScheme\": [\n        \"Explaining the risk of buffer overflow due to lack of bounds checking (2 marks)\",\n        \"Describing at least three mitigation strategies (3 marks)\",\n        \"Providing examples or specific details for each strategy (3 marks)\",\n      ],\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Evaluate\"\n    },\n    {\n      \"question\": \"Describe how variable-length arrays (VLAs) in C work, discussing their advantages and potential drawbacks compared to dynamically allocated arrays.\",\n      \"answer\": \"VLAs, introduced in C99, allow arrays whose size is determined at runtime within a function's scope. For example: `int n; scanf(\\\"%d\\\", &n); int arr[n];`.  This offers flexibility, avoiding the need for dynamic memory allocation using `malloc` and `free`.  However, VLAs have limitations. They are limited to the stack, so their size is constrained by available stack space, which is typically smaller than the heap.  Also, their size is determined at runtime, which can cause issues with some compilers and optimization strategies.  Dynamic arrays using `malloc` provide more flexibility in terms of size and location but demand explicit memory management to prevent leaks.\",\n      \"markingScheme\": [\n        \"Defining and demonstrating VLAs with example code (2 marks)\",\n        \"Explaining how the size of a VLA is determined (1 mark)\",\n        \"Identifying the memory location of VLAs (stack vs. heap) (1 mark)\",\n        \"Discussing the size limitation of VLAs (1 mark)\",\n        \"Comparing VLAs with dynamically allocated arrays, highlighting the trade-offs (3 marks)\",\n      ],\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Analyze\"\n    }\n  ],\n  \"numerical\": [\n    {\n      \"question\": \"An array of type `double` is declared as `double data[5];`. If the base address of the array is 0x1000 and the size of a `double` is 8 bytes, what is the memory address of `data[3]`?\",\n      \"solution\": \"The base address of the array is 0x1000. Each element is 8 bytes (sizeof(double)). The address of data[3] will be the base address plus (3 * sizeof(double)).  0x1000 + (3 * 8) = 0x1000 + 24 = 0x1018\",\n      \"answer\": \"0x1018\",\n      \"courseOutcome\": \"CO4\",\n      \"bloomsLevel\": \"Apply\"\n    },\n    {\n      \"question\": \"Given a character pointer `char *ptr = \\\"hello\\\";`, what will be the value of `ptr + 3`? Explain your answer.\",\n      \"solution\": \"Pointer addition is scaled by the size of the data type.  Since `ptr` is a `char*`, adding 3 increases the address by 3 * sizeof(char), which is 3 bytes.  The resulting address points to the 'l' in \\\"hello\\\". The value itself would be the ASCII value of the letter 'l'.\",\n      \"answer\": \"The memory address 3 bytes after the address pointed to by ptr. The value depends on the character encoding (ASCII typically).\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Apply\"\n    },\n    {\n      \"question\": \"A two-dimensional array `int matrix[3][4]` is allocated.  If each integer takes 4 bytes, what is the total size in bytes of the array?\",\n      \"solution\": \"The array has 3 rows and 4 columns, for a total of 3 * 4 = 12 elements.  Since each element is 4 bytes, the total size is 12 * 4 = 48 bytes.\",\n      \"answer\": \"48 bytes\",\n      \"courseOutcome\": \"CO4\",\n      \"bloomsLevel\": \"Apply\"\n    },\n    {\n      \"question\": \"If a pointer `int *ptr` holds the address 0x1000 and an integer is 4 bytes, what is the address held by `ptr + 2`?\",\n      \"solution\": \"Adding 2 to an integer pointer increases the address by 2 * sizeof(int), which is 2 * 4 = 8 bytes.  Therefore, the new address is 0x1000 + 8 = 0x1008.\",\n      \"answer\": \"0x1008\",\n      \"courseOutcome\": \"CO1\",\n      \"bloomsLevel\": \"Apply\"\n    }\n  ]\n}\n```\n"
}